# 프론트엔드 성능 최적화 제안서

[웹 성능 최적화 점검 보고서]를 바탕으로 프론트엔드(`WooriDo/frontend`)에서 즉시 적용 가능한 최적화 방안을 제안합니다.

## 1. 빌드 및 전송 최적화 (Build & Transfer)

### 📦 Gzip/Brotli 압축 적용
-   **문제점**: 현재 빌드 결과물이 압축되지 않은 상태로 전송됩니다.
-   **해결방안**: `vite-plugin-compression` 플러그인을 도입하여 빌드 시점에 압축 파일을 미리 생성합니다.
-   **예상 효과**: 텍스트 기반 리소스(JS, CSS, HTML) 크기 **70% 이상 감소**.

### 🖼️ 이미지 최적화
-   **문제점**: 원본 이미지가 그대로 사용되고 있습니다.
-   **해결방안**:
    1.  `vite-plugin-imagemin` 도입 (빌드 시 이미지 압축)
    2.  가능하다면 차세대 포맷(**WebP**, **AVIF**)으로 변환하여 서빙
-   **예상 효과**: 이미지 로딩 속도 개선 및 대역폭 절감.

### 🧩 번들링 최적화 (Chunk Splitting)
-   **문제점**: 모든 코드가 하나의 큰 파일로 뭉쳐있을 수 있습니다 (Vendor Blocking).
-   **해결방안**: `vite.config.ts`의 `build.rollupOptions`에서 `manualChunks`를 설정하여, 자주 바뀌지 않는 라이브러리(React, Lodash 등)를 별도 파일로 분리합니다.
-   **예상 효과**: 사용자 브라우저 캐시 효율 증대 (소스코드가 바뀌어도 라이브러리는 다시 받지 않음).

## 2. 로딩 속도 최적화 (Loading Performance)

### ⚡ 코드 스플리팅 (Code Splitting)
-   **문제점**: 초기 페이지 진입 시 당장 필요 없는 페이지의 코드까지 모두 다운로드합니다.
-   **해결방안**: 라우터(`react-router-dom`) 레벨에서 `React.lazy`와 `Suspense`를 사용하여 페이지별로 코드를 분할 로딩합니다.
-   **예상 효과**: **FCP(First Contentful Paint)** 및 **TTI(Time to Interactive)** 획기적 개선.

### 🚫 불필요한 렌더링 방지
-   **문제점**: React 컴포넌트가 불필요하게 자주 재렌더링될 수 있습니다.
-   **해결방안**: `React.memo`, `useMemo`, `useCallback`을 적절히 사용하여 렌더링 비용을 최적화합니다. (특히 리스트 렌더링 시)

## 3. 적용 로드맵

| 단계 | 작업 항목 | 예상 공수 |
| :--- | :--- | :--- |
| **1단계** (즉시) | `vite-plugin-compression` 설치 및 설정 | 0.5일 |
| **1단계** (즉시) | `vite.config.ts` 청크 스플리팅 설정 | 0.5일 |
| **2단계** (단기) | 라우트 기반 `React.lazy` 적용 | 1~2일 |
| **3단계** (중기) | 이미지 최적화 파이프라인 구축 | 2~3일 |

---
**결론**: 1단계 작업(압축 및 청크 분리)은 적은 공수로 큰 효과를 볼 수 있으므로, 이번 스프린트 내 적용을 강력히 권장합니다.
